{"version":3,"sources":["voronoi.js"],"names":["generateVoronoiPoints","points","width","height","distanceCallback","colors","map","point","e","color","Array","fill","Math","ceil","random","imageData","index","coordinate","closest","distance","i","array","dup","some","d","sort","a","b","generateL1Voronoi","sitePoints","sites","site","bisectors","findBisector","curryFindBisector","findL1Bisector","graph","recursiveSplit","filteredBisectors","compound","find","polygonPoints","reduce","total","bisector","startBisector","isPointonEdge","startingPoints","length","reverse","used","last","nextBisector","filter","every","c","eDistance","cDistance","Infinity","nextPoints","samePoint","head","tail","cornerX","cornerY","push","join","splitArray","splitPoint","L","slice","R","neightborArray","startingInfo","determineStartingBisector","initialBisector","startingBisector","initialR","nearestNeighbor","initialL","w","upStrokeArray","walkMergeLine","downStrokeArray","mergeArray","forEach","mergeLine","clearOutOrphans","currentR","currentL","currentBisector","currentCropPoint","goUp","crossedBorder","trimBisector","cropLArray","bisectorIntersection","hopTo","isNewBisectorUpward","console","log","angle","findHopTo","candidates","newMergeLine","isBisectorTrapped","cropRArray","cropL","cropR","leftOrphan","checkForOphans","rightOrphan","findCorrectW","newMergeBisector","abs","P1","P2","atan2","PI","lastIntersect","z","zline","intersection","startingIntersection","nextR","wTrap","isTrapped","trapper","trapped","hopToA","hopToB","mergeLineA","mergeLineB","extremeA","getExtremePoint","extremeB","callback","xDistance","yDistance","midpoint","slope","intercetpt","vertexes","up","warn","internalPoints","byHeight","sortedVerts","intersections","orphanage","trapPoint","hopFrom","max","min","target","intersector","passedIntersection","backtrim","newPoints","polygonSite","undefined","intercept","isAboveLine","B1","B2","anchor","j","intersect","segementIntersection","notCompound","innerIntersections","L1","L2","ua","ub","denom"],"mappings":"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","file":"voronoi.js","sourcesContent":["/**\n * Generate Voronoi points via a basic, naive algorithm. Takes any distance callback\n * \n * @param {array} points \n * @param {number} width \n * @param {number} height \n * @param {function} distanceCallback\n * @returns {Array<Site>} \n */\n\nfunction generateVoronoiPoints(points, width, height, distanceCallback){\n\n    let colors = points.map(e =>{ return {point:e, color: new Array(3).fill(0).map(d => Math.ceil(Math.random() * 255))}})\n\n    let imageData = new Array(width * height).fill(0).map((point, index) => {\n        let coordinate = [index % height , Math.ceil(index / height)];\n        let closest = colors.map( e => { return {color:e, distance:distanceCallback(e.point, coordinate)}})\n                            .map( (e, i, array) => {return {color:e.color, distance:e.distance, dup:array.some( d => d.distance === e.distance && d !== e)}})\n                            .sort( (a, b) => a.distance - b.distance )\n\n        return closest[0].dup ? [0,0,0] : closest[0].color.color;\n    });\n    \n    return imageData;\n};\n\n/**\n * Generate an L1 Voronoi diagram\n * \n * @param {array} sitePoints \n * @param {number} width \n * @param {number} height\n * @returns {Array<Site>} \n */\n\nfunction generateL1Voronoi(sitePoints,width,height){\n\n    // sort points by x axis, breaking ties with y\n    let sites = sitePoints.sort((a,b)=>{\n        if(a[0] !== b[0]){\n            return a[0] - b[0];\n        }\n        else{\n            return a[1] - b[1];\n        }\n    }).map(e => {return {site:e, bisectors:[]}});\n\n    const findBisector = curryFindBisector(findL1Bisector, width, height);\n    const graph = recursiveSplit(sites, findBisector, width, height);\n    //console.log(graph);\n    return graph.map(site => {\n        //console.log(site);\n\n        let filteredBisectors = site.bisectors.map(e => {\n            return !e.compound ?\n                   e :\n                   e.points.find(d => d.site === site);\n        })\n\n        site.polygonPoints = filteredBisectors.reduce((total, bisector, index, bisectors)=>{\n\n            if(index === 0){\n\n                //find a bisector on an edge if you have one\n                let startBisector = bisectors.find(e => {\n                    return e.points.some(e => isPointonEdge(e));\n                }) || bisector;\n\n                let startingPoints = startBisector.points;\n                \n                if(isPointonEdge(startingPoints[startingPoints.length - 1])){\n                    startingPoints = startingPoints.reverse();\n                }\n\n                return {\n                    points:startingPoints,\n                    used:[startBisector]\n                }; \n            }\n            else{\n                let last = total.points[total.points.length -1];\n                \n                let nextBisector = bisectors.filter(e => total.used.every(d => e !== d)).reduce((c,e) => {\n                    \n                    let eDistance = distance(last, e.points[0]) < distance(last, e.points[e.points.length - 1]) ? distance(last, e.points[0]) : distance(last, e.points[e.points.length - 1]);   \n                    let cDistance = distance(last, c.points[0]) < distance(last, c.points[c.points.length - 1]) ? distance(last, c.points[0]) : distance(last, c.points[c.points.length - 1]);                       \n                    \n                    return eDistance < cDistance ? e : c;\n                },{points:[[Infinity,Infinity]]});\n\n                let nextPoints = nextBisector.points; \n\n                if(samePoint(nextPoints[nextPoints.length - 1], last)){\n                    nextPoints = nextPoints.reverse();\n                }\n\n                nextPoints = nextPoints.filter(e => !samePoint(e,last));\n\n                return {\n                    points:[...total.points, ...nextPoints],\n                    used: [...total.used, nextBisector]\n                };\n            }\n        },{}).points;\n\n        let head = site.polygonPoints[0];\n        let tail = site.polygonPoints[site.polygonPoints.length - 1]\n\n        if(isPointonEdge(head) && isPointonEdge(tail)){\n            let cornerX = (head[0] === 0 || head[0] === width) ? head[0] : tail[0];\n            let cornerY = (head[1] === 0 || head[1] === height) ? head[1] : tail[1];\n            \n            site.polygonPoints.push([cornerX, cornerY]);\n        }\n\n        site.d = `M ${ site.polygonPoints.map(e => e.join(\" \")).join(\" L\")} Z`;\n\n        return site;\n    });\n\n    function isPointonEdge(point) {\n        return point[0] === 0 ||\n               point[0] === width ||\n               point[1] === 0 ||\n               point[1] === height;\n    }\n\n}\n\n/**\n * Recursivly split and merge sets of points\n * \n * @param {Array} splitArray \n * @param {function} findBisector \n * @param {Number} width \n * @param {Number} height\n * @returns {Array<Site>}\n */\nfunction recursiveSplit(splitArray, findBisector, width, height){\n    \n    // if its got more than two points in it, split it recursively\n    if(splitArray.length > 2){\n        let splitPoint = (splitArray.length - splitArray.length % 2) / 2\n\n        // merge the child diagrams\n        let L = recursiveSplit(splitArray.slice(0,splitPoint), findBisector, width, height);\n        let R = recursiveSplit(splitArray.slice(splitPoint), findBisector, width, height);\n\n        \n        // the current working sites\n        let neightborArray = R.sort((a,b) => distance(L[L.length - 1].site,a.site) - distance(L[L.length - 1].site,b.site));\n    \n        let startingInfo = determineStartingBisector(L[L.length - 1], neightborArray[0], width, null, findBisector);\n\n        let initialBisector = startingInfo.startingBisector;\n        let initialR = startingInfo.nearestNeighbor;\n        let initialL = startingInfo.w;\n\n        let upStrokeArray = walkMergeLine(initialR, initialL, initialBisector, [width,height], true, null, [], findBisector);\n        let downStrokeArray = walkMergeLine(initialR, initialL, initialBisector, [0,0], false, null, [], findBisector);\n\n        // combine all teh merge arrays\n        let mergeArray = [initialBisector, ...upStrokeArray, ...downStrokeArray];            \n\n        mergeArray.forEach(bisector => {\n            bisector.mergeLine = splitArray.length;\n            bisector.sites[0].bisectors = clearOutOrphans(bisector.sites[0], bisector.sites[1]);\n            bisector.sites[1].bisectors = clearOutOrphans(bisector.sites[1], bisector.sites[0]);                \n\n            bisector.sites.forEach(site => {\n                site.bisectors.push(bisector);\n            })\n        });\n\n        return [...L, ...R];    \n\n    }\n\n    // otherwise, determine te vertexes if its got two sites\n    else if(splitArray.length === 2){\n        let bisector = findBisector(...splitArray);\n        //console.log(bisector);\n        splitArray.forEach(e => { e.bisectors.push(bisector) });\n        return splitArray;\n    }\n\n    // if its got just one, just return it\n    else{\n        return splitArray;\n    }\n}\n\n/**\n * \n * @param {Site} currentR \n * @param {Site} currentL \n * @param {Bisector} currentBisector \n * @param {Array} currentCropPoint \n * @param {Boolean} goUp \n * @param {Bisector} crossedBorder \n * @param {Array} mergeArray - Array of Bisectors \n * @param {function} findBisector\n * @returns {Array<Bisector>} \n */\nfunction walkMergeLine(currentR, currentL, currentBisector, currentCropPoint, goUp, crossedBorder = null, mergeArray = [], findBisector){\n    \n    if(\n        !currentBisector.sites.every(e => e === currentR || e === currentL)\n    ){\n\n        currentBisector = findBisector(currentR,currentL);\n\n        trimBisector(currentBisector, crossedBorder, currentCropPoint, true);\n        \n        mergeArray.push(currentBisector);\n    }\n    \n    let cropLArray = currentL.bisectors\n                        .map(e => {return {bisector:e, point:bisectorIntersection(currentBisector, e, currentCropPoint)}})\n                        .filter(e => {\n                            let hopTo = e.bisector.sites.find(d => d !== currentL);\n                            return e.point && (goUp === isNewBisectorUpward(hopTo, currentL, currentR, goUp)) && !samePoint(e.point, currentCropPoint);\n                        })\n                        .sort((a, b) => {\n                            if(samePoint(a.point,b.point)){\n                                console.log(\"corner problem Left\")\n                                //console.log(angle(currentL.site, findHopTo(b.bisector, currentL).site), angle(currentL.site, findHopTo(a.bisector, currentL).site) )\n                                return angle(currentL.site, findHopTo(b.bisector, currentL).site) - angle(currentL.site, findHopTo(a.bisector, currentL).site)\n                            }\n                            return angle(currentL.site, findHopTo(b.bisector, currentL).site) - angle(currentL.site, findHopTo(a.bisector, currentL).site)                            \n                            //return goUp ? a.point[1] - b.point[1] : b.point[1] - a.point[1];\n                        })\n                        .filter((e, i, candidates) => {\n                            let hopTo = findHopTo(e.bisector, currentL);\n                            let newMergeLine = findBisector(currentR, hopTo);\n                            trimBisector(newMergeLine, e.bisector, e.point);\n                            return candidates.every(d => !isBisectorTrapped(findHopTo(d.bisector, currentL), newMergeLine) || findHopTo(d.bisector, currentL) === hopTo);\n                        });\n    \n    let cropRArray = currentR.bisectors\n                        .map(e => {return {bisector:e, point:bisectorIntersection(currentBisector, e, currentCropPoint)}})\n                        .filter(e => {\n                            let hopTo = e.bisector.sites.find(d => d !== currentR);\n                            return e.point && (goUp === isNewBisectorUpward(hopTo, currentR, currentL, goUp)) && !samePoint(e.point, currentCropPoint);\n                        })\n                        .sort((a, b) => {\n                            if(samePoint(a.point,b.point)){\n                                console.log(\"corner problem Right\");\n                                //console.log(findHopTo(a.bisector,currentR),checkForOphans(currentL, findHopTo(a.bisector,currentR), goUp, findBisector), checkForOphans(currentL, findHopTo(b.bisector,currentR), goUp, findBisector))\n                                return angle(currentR.site, findHopTo(a.bisector, currentR).site) - angle(currentR.site, findHopTo(b.bisector, currentR).site)\n                            }\n                            return angle(currentR.site, findHopTo(a.bisector, currentR).site) - angle(currentR.site, findHopTo(b.bisector, currentR).site)                            \n                            //return goUp ? a.point[1] - b.point[1] : b.point[1] - a.point[1];\n                        })\n                        .filter((e, i, candidates) => {\n                            let hopTo = findHopTo(e.bisector, currentR);\n                            let newMergeLine = findBisector(currentL, hopTo);\n                            trimBisector(newMergeLine, e.bisector, e.point);\n                            return candidates.every(d => !isBisectorTrapped(findHopTo(d.bisector, currentR), newMergeLine) || findHopTo(d.bisector, currentR) === hopTo);\n                        });\n\n    let cropL = cropLArray.length > 0 && cropLArray[0] !== currentBisector ? cropLArray[0] : {bisector:null, point:goUp ? [Infinity, Infinity] : [-Infinity, -Infinity]};\n    let cropR = cropRArray.length > 0 && cropRArray[0] !== currentBisector ? cropRArray[0] : {bisector:null, point:goUp ? [Infinity, Infinity] : [-Infinity, -Infinity]};\n    // console.log(cropLArray, cropRArray, goUp, currentL.site, currentR.site, checkForOphans(currentR, currentL, goUp, findBisector), checkForOphans(currentL, currentR, goUp, findBisector));                    \n    // If no intersection, we're done.\n    if(\n        (!cropL.bisector && !cropR.bisector)\n    ){\n        // If the final merge bisector is horizontal, check to see if there are orphans \n        let leftOrphan = checkForOphans(currentR, currentL, goUp, findBisector); \n        let rightOrphan = checkForOphans(currentL, currentR, goUp, findBisector);\n\n        if( \n            leftOrphan \n        ){\n            // Remove trapped bisector\n            leftOrphan.sites.forEach(site => {\n                site.bisectors = site.bisectors.filter(e => e !== leftOrphan);\n            });\n\n            let hopTo = findHopTo(leftOrphan, currentL);\n\n            currentR = findCorrectW(currentR, hopTo, findBisector);                        \n            let newMergeBisector = findBisector(hopTo, currentR);\n\n            mergeArray.push(newMergeBisector);\n\n            return walkMergeLine(currentR, hopTo, newMergeBisector, currentCropPoint, goUp, crossedBorder, mergeArray, findBisector);\n\n        }\n        else if(\n            rightOrphan\n        ){\n            // Remove trapped bisector\n            rightOrphan.sites.forEach(site => {\n                site.bisectors = site.bisectors.filter(e => e !== rightOrphan);\n            });\n\n            let hopTo = findHopTo(rightOrphan, currentR);\n\n            currentL = findCorrectW(currentL, hopTo, findBisector);                        \n            let newMergeBisector = findBisector(hopTo, currentL);\n            \n            mergeArray.push(newMergeBisector);                        \n\n            return walkMergeLine(hopTo, currentL, newMergeBisector, currentCropPoint, goUp, crossedBorder, mergeArray, findBisector);\n        }\n        \n        return mergeArray;\n    }\n\n    if(Math.abs(cropR.point[1] - currentCropPoint[1]) < Math.abs(cropL.point[1] - currentCropPoint[1])){\n        trimBisector(cropR.bisector, currentBisector, cropR.point);\n        trimBisector(currentBisector, cropR.bisector, cropR.point);\n        currentR.bisectors.filter(e => e.compound).forEach(d => trimBisector(d, currentBisector));\n        //currentBisector.intersections.push(cropR.point);\n        crossedBorder = cropR.bisector;\n        currentR = cropR.bisector.sites.find(e => e !== currentR);\n        currentCropPoint = cropR.point;               \n    }\n    else if(Math.abs(cropR.point[1] - currentCropPoint[1]) > Math.abs(cropL.point[1] - currentCropPoint[1])){\n        trimBisector(cropL.bisector, currentBisector, cropL.point);\n        trimBisector(currentBisector, cropL.bisector, cropL.point);\n        currentL.bisectors.filter(e => e.compound).forEach(d => trimBisector(d, currentBisector));        \n        //currentBisector.intersections.push(cropL.point);\n        crossedBorder = cropL.bisector;\n        currentL = cropL.bisector.sites.find(e => e !== currentL);\n        currentCropPoint = cropL.point;                                       \n    }\n    else{\n        console.log(\"double moving on...\");\n        trimBisector(cropR.bisector, currentBisector, cropR.point);\n        trimBisector(currentBisector, cropR.bisector, cropR.point);\n        currentR.bisectors.filter(e => e.compound).forEach(d => trimBisector(d, currentBisector));        \n        currentL.bisectors.filter(e => e.compound).forEach(d => trimBisector(d, currentBisector));\n\n        //currentBisector.intersections.push(cropR.point);\n        crossedBorder = cropR.bisector;\n        currentR = cropR.bisector.sites.find(e => e !== currentR);\n        currentCropPoint = cropR.point;\n\n        trimBisector(cropL.bisector, currentBisector, cropL.point);\n        trimBisector(currentBisector, cropL.bisector, cropL.point);\n        //currentBisector.intersections.push(cropL.point);\n        crossedBorder = cropL.bisector;\n        currentL = cropL.bisector.sites.find(e => e !== currentL);\n        currentCropPoint = cropL.point;\n    }\n\n    currentR.bisectors.forEach(e => trimBisector(currentBisector, e));\n    currentL.bisectors.forEach(e => trimBisector(currentBisector, e));\n\n    return walkMergeLine(currentR, currentL, currentBisector, currentCropPoint, goUp, crossedBorder, mergeArray, findBisector);            \n    \n}\n\nfunction angle(P1, P2){\n    let angle = Math.atan2(P2[1] - P1[1], P2[0] - P1[0]);\n\n    if(angle < 0){\n        angle = Math.PI + Math.PI + angle; \n    }\n\n    return angle;\n}\n\n/**\n * determine starting bisector for the merge process\n * \n * @param {Array} w - starting point in form [x, y] \n * @param {Array} nearestNeighbor point in form [x, y]\n * @param {number} width \n * @param {Array} lastIntersect point in form [x,y] \n * @param {function} findBisector  \n */\nfunction determineStartingBisector(w, nearestNeighbor, width, lastIntersect = null, findBisector){\n    \n    let z = [width, w.site[1]];\n    \n    if(!lastIntersect){\n        lastIntersect = w.site;\n    }\n\n    let zline = {points:[w.site,z], compound:false};\n\n    let intersection = nearestNeighbor.bisectors.map(bisector => {\n        return {point:bisectorIntersection(zline,bisector, w.site), bisector:bisector}\n    }).find(intersection => intersection.point);\n    \n    if(intersection && distance(w.site, intersection.point) > distance(nearestNeighbor.site, intersection.point)){\n        var startingBisector = findBisector(w, nearestNeighbor);\n        return {\n            startingBisector: startingBisector,\n            w:w,\n            nearestNeighbor: nearestNeighbor,\n            startingIntersection: intersection.point ? intersection.point : w.site\n        };\n    }\n    else if(intersection && distance(w.site, intersection.point) < distance(nearestNeighbor.site, intersection.point) && intersection.point[0] > lastIntersect[0] ){\n        let nextR = intersection.bisector.sites.find(e => e !== nearestNeighbor);\n        return determineStartingBisector(w, nextR, width, intersection.point, findBisector);\n    }\n    else{\n        w = findCorrectW(w,nearestNeighbor, findBisector);\n        \n        let startingBisector = findBisector(w, nearestNeighbor);\n\n        return {\n            startingBisector: startingBisector,\n            w:w,\n            nearestNeighbor: nearestNeighbor,\n            startingIntersection: intersection ? intersection.point : w.site\n        };\n\n    }\n\n};\n\n/**\n * Ensure that the starting point is correct and would not result in a trapped bisector\n * \n * @param {Array} w in form [x,y] \n * @param {Array} nearestNeighbor in form [x,y]\n * @param {function} findBisector\n * @returns {Array} in form [x,y] \n */\nfunction findCorrectW(w, nearestNeighbor, findBisector){\n    \n    var startingBisector = findBisector(w, nearestNeighbor);        \n\n    let wTrap = w.bisectors.map(e => {\n        let hopTo = findHopTo(e,w);\n        return {hopTo:hopTo, isTrapped:isBisectorTrapped(hopTo,startingBisector)}\n    })\n    .filter(e => e.isTrapped)\n    .sort((a,b) => distance(a.hopTo.site,nearestNeighbor.site) - distance(b.hopTo.site, nearestNeighbor.site))[0];\n\n    if(wTrap){\n        return findCorrectW(wTrap.hopTo, nearestNeighbor, findBisector);\n    }\n    else{\n        return w;\n    }\n}\n\n/**\n * Function that recursivly checks for orphaned besectors\n * \n * @param {Site} trapper \n * @param {Site} trapped \n * @param {boolean} goUp \n * @param {function} findBisector \n */\nfunction checkForOphans(trapper, trapped, goUp, findBisector){\n    \n    return trapped.bisectors.filter(bisector => {\n        let hopTo = findHopTo(bisector, trapped);\n        return goUp === hopTo.site[1] < trapped.site[1] && isBisectorTrapped(trapper,bisector); \n    }).sort((a,b) => {\n\n        let hopToA = findHopTo(a, trapped);\n        let hopToB = findHopTo(b, trapped);\n\n        let mergeLineA = findBisector(hopToA, trapper);\n        let mergeLineB = findBisector(hopToB, trapper);\n\n        let extremeA = getExtremePoint(mergeLineA, goUp);\n        let extremeB = getExtremePoint(mergeLineB, goUp);\n        \n        return goUp ? extremeB - extremeA : extremeA - extremeB;\n    })[0];\n    \n}\n\n/**\n * Currys find bisector function with the current width, height\n * \n * @param {function} callback \n * @param {number} width \n * @param {number} height\n * @return {function} \n */\nfunction curryFindBisector(callback, width, height){\n    return function(P1, P2){\n        return callback(P1, P2, width, height);\n    }\n}\n\n/**\n * Generate L1 bisector between two sites\n * \n * @param {Site} P1 \n * @param {Site} P2 \n * @param {number} width \n * @param {number} height\n * @returns {bisector} \n */\nfunction findL1Bisector(P1, P2, width, height){\n    \n    \n    let xDistance = P1.site[0] - P2.site[0];\n    let yDistance = P1.site[1] - P2.site[1];\n\n    let midpoint = [\n        (P1.site[0] + P2.site[0]) / 2,\n        (P1.site[1] + P2.site[1]) / 2\n    ];\n\n    let slope = yDistance/xDistance > 0 ? -1 : 1;\n\n    let intercetpt = midpoint[1] - midpoint[0] * slope;\n\n    let vertexes = [];\n    let up = null;\n    \n    // special case \n    if(Math.abs(xDistance) === Math.abs(yDistance)){\n        console.warn(\"square bisector\");\n        \n        let internalPoints = [\n            [(P1.site[1] - intercetpt) / slope, P1.site[1]],\n            [(P2.site[1] - intercetpt) / slope, P2.site[1]]\n        ];\n\n        let byHeight = [P1,P2].sort((a,b) => a.site[1] - b.site[1]);\n        let sortedVerts = internalPoints.sort((a,b) => a[1] - b[1]);\n        \n        vertexes = [\n            {\n                site:byHeight[0],\n                sites:[P1, P2],\n                points:[\n                    [sortedVerts[0][0],0],\n                    ...sortedVerts,\n                    [slope === -1 ? 0 : width, sortedVerts[1][1]]\n                ],\n                compound:false,\n                intersections:[]\n            },\n            {\n                site:byHeight[1],\n                sites:[P1, P2],\n                points:[\n                    [slope === -1 ? width : 0, sortedVerts[0][1]],\n                    ...sortedVerts,\n                    [sortedVerts[1][0], height]\n                ],\n                compound:false,\n                intersections:[]\n            }\n        ];\n\n\n        return {sites:[P1, P2], up:true, points:vertexes, intersections:[], compound:true};        \n    }\n    \n\n    \n    if(Math.abs(xDistance) === 0){\n        vertexes = [\n            [0, midpoint[1]],\n            [width, midpoint[1]]\n        ];\n\n        return {sites:[P1, P2], up:false, points:vertexes, intersections:[], compound:false};\n    }\n\n    if(Math.abs(yDistance) === 0){\n        vertexes = [\n            [midpoint[0], 0],\n            [midpoint[0], height]\n        ];\n\n        return {sites:[P1, P2], up:true, points:vertexes, intersections:[], compound:false};\n    }\n    if(Math.abs(xDistance) > Math.abs(yDistance)){\n        vertexes = [\n            [(P1.site[1] - intercetpt) / slope, P1.site[1]],\n            [(P2.site[1] - intercetpt) / slope, P2.site[1]]\n        ];\n\n        up = true;\n    }\n    else{\n        vertexes = [\n            [P1.site[0] , (P1.site[0] * slope) + intercetpt ],\n            [P2.site[0] , (P2.site[0] * slope) + intercetpt ]\n        ];\n\n        up = false;\n    }\n\n    let bisector = {sites:[P1, P2], up:up, points:[], intersections:[], compound:false};    \n\n    if(up){\n        const sortedVerts = vertexes.sort((a,b) => a[1] - b[1]);\n\n        \n        bisector.points = [\n            [sortedVerts[0][0], 0],\n            ...sortedVerts,\n            [sortedVerts[1][0], height] \n        ].sort((a,b) => a[1] - b[1]);\n        \n    }\n    else{\n        const sortedVerts = vertexes.sort((a,b) => a[0] - b[0]);            \n        \n        bisector.points = [\n            [0,sortedVerts[0][1]],\n            ...sortedVerts,\n            [width,sortedVerts[1][1]]\n        ].sort((a,b) => a[0] - b[0]);\n    }\n\n    //console.log(bisector.points.length);\n    return bisector;\n}\n\n/**\n * Clear out orphans when a new merge line is created\n * \n * @param {Site} orphanage \n * @param {Site} trapPoint\n * @returns {Array<Bisector>} \n */\nfunction clearOutOrphans(orphanage, trapPoint){\n    return orphanage.bisectors.filter(bisector => !isBisectorTrapped(trapPoint, bisector));\n}\n\n/**\n * Finds other point across a bisector\n * \n * @param {Bisector} bisector \n * @param {Site} hopFrom\n * @returns {Site} \n */\nfunction findHopTo(bisector, hopFrom){\n    return bisector.sites.find(e => e !== hopFrom);\n}\n\n\n/**\n * Find L1 distance\n * \n * @param {Array} P1 in form [x,y] \n * @param {Array} P2 in form [x,y]\n * @returns {number}\n */\nfunction distance(P1, P2){\n    return Math.abs(P1[0] - P2[0]) + Math.abs(P1[1] - P2[1]);\n}\n\n/**\n * Determine if bisector is trapped in a site's polygon\n * Trapped is defined as all the points of a bisector being closer to the trap point than either if its own sites.\n * \n * @param {Site} trapPoint \n * @param {Bisector} bisector\n * @returns {boolean} \n */\nfunction isBisectorTrapped(trapPoint, bisector){\n    if(!bisector.compound){\n        return bisector.points.every(point => distance(trapPoint.site, point) <= distance(bisector.sites[0].site, point) && distance(trapPoint.site, point) <= distance(bisector.sites[1].site, point));    \n    }\n    else{\n        return isBisectorTrapped(trapPoint, bisector.points[0]) && isBisectorTrapped(trapPoint, bisector.points[1]);\n    }\n}\n\n/**\n * Find the highest or lowest point of a potential bisector.\n * \n * @param {Bisector} bisector \n * @param {boolean} goUp \n */\nfunction getExtremePoint(bisector, goUp){\n    if(!bisector.compound){\n        return bisector.points.reduce((c,e)=>{\n            return goUp ? Math.max(e[1],c) : Math.min(e[1],c);\n        }, goUp ? -Infinity : Infinity);\n    }\n    else{\n        return bisector.points.map(e => {\n            return getExtremePoint(e, goUp);        \n        })\n        .sort((a,b) => {\n            return goUp ? a[1] - b[1] : b[1] - a[1];\n        });\n    }\n}\n\n/**\n * Trim a bisector at a particular point, discarding the points lying within the other polygon\n * \n * @param {Bisector} target \n * @param {Bisector} intersector \n * @param {Array} intersection in form [x,y] \n */\nfunction trimBisector(target, intersector, passedIntersection, backtrim){\n\n    if(!target.compound && !intersector.compound){\n\n        let intersection = bisectorIntersection(target, intersector);\n        \n        if(!intersection && backtrim){\n            console.log(intersection, target, intersector); \n            return; \n        }\n        \n        let newPoints = target.points.reduce((c, e, i, array)=> {\n            if(i + 1 >= array.length){\n                return c;\n            }\n            //console.log(array[i+1], array, i);\n            if(distance(e, intersection) + distance(array[i+1], intersection) === distance(e, array[i+1])){\n                return [...c, e, intersection];\n            }\n            else{\n                return [...c, e];\n            }\n        },[]);\n       \n        // add the last one\n        newPoints = [...newPoints, target.points[target.points.length - 1]];\n        \n        let polygonSite = intersector.sites.find(e => target.sites.find(d => d === e) === undefined);\n        target.intersections.push(intersection)\n        target.points = newPoints.filter(e => {\n            return (distance(e, target.sites[0].site) <= distance(e, polygonSite.site) || distance(e, target.sites[1].site) <= distance(e, polygonSite.site)) || samePoint(e, intersection)\n        });\n    }\n    else if(!target.compound && intersector.compound){\n        //console.log(\"intersector compound\", target, intersector);\n        trimBisector(target, intersector.points[0]);\n        trimBisector(target, intersector.points[1]);        \n    }\n    else if(target.compound && !intersector.compound){\n        //console.log(\"target compound\", target, intersector);        \n        trimBisector(target.points[0], intersector);\n        trimBisector(target.points[1], intersector);\n    }\n    else{\n        //console.log(\"both compound\", target, intersector);\n        trimBisector(target.points[0], intersector[0]);\n        trimBisector(target.points[0], intersector[1]);\n        trimBisector(target.points[1], intersector[0]);\n        trimBisector(target.points[1], intersector[1]);\n    }\n\n};\n\n/**\n * Check to see if a bisector is traveling upward or downward with repect tot eh y axis\n * \n * @param {Site} hopTo \n * @param {Site} hopFrom \n * @param {Site} site\n * @returns {boolean} \n */\nfunction isNewBisectorUpward(hopTo, hopFrom, site, goUp){\n    \n    let slope = (hopTo.site[1] - site.site[1])/(hopTo.site[0] - site.site[0]);\n    let intercept = hopTo.site[1] - (slope * hopTo.site[0]);\n\n    // this needs to be here to account for bisectors \n    if(Math.abs(slope) === Infinity){\n        //console.log(\"verticle slope :/\");\n        //console.log( \"Hop From:\",hopFrom.site, \"Hop to:\", hopTo.site, \"site:\",site.site, \"is upward\", site.site[1] < hopTo.site[1] );\n        return site.site[1] > hopTo.site[1];\n    }\n\n    let isAboveLine = hopFrom.site[1] > (slope * hopFrom.site[0]) + intercept;\n    \n    return isAboveLine;\n}\n\n/**\n * Find intersection of two bisectors, if it exists\n * \n * @param {Bisector} B1 \n * @param {Bisector} B2\n * @returns {Array or boolean} \n */\nfunction bisectorIntersection(B1, B2, anchor){\n    if(B1 === B2){\n        return false;\n    }\n    // simple case, if they're both not compound\n    if(!B1.compound && !B2.compound){\n        //console.log(B1, B2);\n        for(let i = 0; i < B1.points.length - 1; i++){\n            for(let j = 0; j < B2.points.length - 1; j++){\n                let intersect = segementIntersection([B1.points[i], B1.points[i+1]], [B2.points[j], B2.points[j+1]], i, j);\n    \n                if(intersect){\n                    return intersect;\n                }\n            }\n        }\n    }\n    // if one is compound\n    else if(!B1.compound || !B2.compound){\n        let compound = [B1,B2].find(e => e.compound);\n        let notCompound = [B1,B2].find(e => !e.compound);\n\n        let intersections = compound.points.map(e => {\n            return bisectorIntersection(e,notCompound)\n        })\n        .filter(e => {\n            return e;\n        })\n        .sort((a,b) => {\n            return distance(a, anchor) - distance(b, anchor);\n        });\n\n        return intersections.length > 0 ? intersections[0] : false;\n    }\n    // if both are compound\n    else{\n\n        let intersections = B2.points.map(d => {\n\n            let innerIntersections = B1.points.map(e => {\n                return bisectorIntersection(e,d);\n            })\n            .filter(e => {\n                return e;\n            })\n            .sort((a,b) => {\n                return distance(a, anchor) - distance(b, anchor);\n            });\n    \n            return innerIntersections.length > 0 ? innerIntersections[0] : false;\n        })\n        .filter(e => {\n            return e.intersection;\n        })\n        .sort((a,b) => {\n            return distance(a, anchor) - distance(b, anchor);\n        });\n\n        return intersections.length > 0 ? intersections[0] : false;\n        \n    }\n\n\n\n    \n\n    return false;\n}\n\n/**\n * find intersection of two line segements, if it exists\n * \n * @param {LineSegment} L1 - in form [[x,y],[x,y]] \n * @param {*} L2 - in form [[x,y],[x,y]]\n * @returns {Array or boolean}\n */\nfunction segementIntersection(L1, L2){\n    \n    var ua, ub, denom = (L2[1][1] - L2[0][1])*(L1[1][0] - L1[0][0]) - (L2[1][0] - L2[0][0])*(L1[1][1] - L1[0][1]);\n    \n    // If denom is zero, that mean that both segemnts are verticle or horizontal, and we need to account for that.\n    if (denom == 0) {\n        return null;\n    }\n    ua = ((L2[1][0] - L2[0][0])*(L1[0][1] - L2[0][1]) - (L2[1][1] - L2[0][1])*(L1[0][0] - L2[0][0]))/denom;\n    ub = ((L1[1][0] - L1[0][0])*(L1[0][1] - L2[0][1]) - (L1[1][1] - L1[0][1])*(L1[0][0] - L2[0][0]))/denom;\n\n    if(\n        !(ua >= 0 && ua <= 1 &&\n        ub >= 0 && ub <= 1)\n    ){\n        return false;\n    }\n\n    return [\n        L1[0][0] + ua*(L1[1][0] - L1[0][0]),\n        L1[0][1] + ua*(L1[1][1] - L1[0][1])\n    ];\n\n}\n\n/**\n * Determine if two points are the same point\n * \n * @param {Array} P1 - in form [x,y] \n * @param {Array} P2 - in form [x,y]\n */\nfunction samePoint(P1, P2){\n    return P1[0] === P2[0] && P1[1] === P2[1];\n}\n\n\nexport {generateVoronoiPoints, generateL1Voronoi};\n"]}