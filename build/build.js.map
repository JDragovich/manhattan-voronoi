{"version":3,"sources":["voronoi.js"],"names":["generateVoronoiPoints","points","width","height","distanceCallback","colors","map","point","e","color","Array","fill","Math","ceil","random","imageData","index","coordinate","closest","reduce","c","isArray","every","d","Infinity","cleanData","data","forEach","i","j","abs","generateL1Voronoi","sitePoints","nudgeData","console","log","sites","sort","a","b","site","bisectors","findBisector","curryFindBisector","findL1Bisector","graph","recursiveSplit","polygonPoints","total","bisector","startBisector","find","some","isPointonEdge","startingPoints","length","reverse","used","last","nextBisector","filter","eDistance","distance","cDistance","nextPoints","samePoint","corners","arePointsOnSameEdge","filteredCorners","bisectorIntersection","angle","join","neighbors","findHopTo","P1","P2","splitArray","splitPoint","L","slice","R","neightborArray","startingInfo","determineStartingBisector","initialBisector","startingBisector","initialR","nearestNeighbor","initialL","w","upStrokeArray","walkMergeLine","downStrokeArray","mergeArray","mergeLine","clearOutOrphans","push","currentR","currentL","currentBisector","currentCropPoint","goUp","crossedBorder","trimBisector","cropLArray","hopTo","isNewBisectorUpward","candidates","newMergeLine","isBisectorTrapped","cropRArray","cropL","cropR","leftOrphan","checkForOphans","rightOrphan","findCorrectW","newMergeBisector","determineFirstBorderCross","intersections","atan2","PI","lastIntersect","z","zline","intersection","startingIntersection","nextR","wTrap","isTrapped","trapper","trapped","hopToA","hopToB","mergeLineA","mergeLineB","extremeA","getExtremePoint","extremeB","callback","xDistance","yDistance","midpoint","slope","intercetpt","vertexes","up","Error","JSON","stringify","compound","sortedVerts","orphanage","trapPoint","hopFrom","max","min","target","intersector","polygonSite","undefined","newPoints","intercept","isAboveLine","B1","B2","intersect","segementIntersection","L1","L2","ua","ub","denom"],"mappings":"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","file":"build.js","sourcesContent":["/**\n * Generate Voronoi points via a basic, naive algorithm. Takes any distance callback\n * \n * @param {array} points \n * @param {number} width \n * @param {number} height \n * @param {function} distanceCallback\n * @returns {Array<Site>} \n */\n\nfunction generateVoronoiPoints(points, width, height, distanceCallback){\n\n    let colors = points.map(e =>{ return {point:e, color: new Array(3).fill(0).map(d => Math.ceil(Math.random() * 255))}})\n\n    let imageData = new Array(width * height).fill(0).map((point, index) => {\n        let coordinate = [index % height , Math.ceil(index / height)];\n        let closest = colors.reduce((c,e) => {\n\n            if(Array.isArray(c)){\n                return c.every(d => distanceCallback(d.point, coordinate) < distanceCallback(e.point, coordinate) ) ? c : e;\n            }\n            else if(distanceCallback(c.point, coordinate) === distanceCallback(e.point, coordinate)){\n                return [c,e];\n            }\n            else{\n                return distanceCallback(c.point, coordinate) < distanceCallback(e.point, coordinate) ? c : e;\n            }\n\n        }, {point:[Infinity,Infinity]});\n\n        return Array.isArray(closest) ? [0,0,0] : closest.color;\n    });\n    \n    return imageData;\n};\n\n/**\n * Nudge points to hopefully eliminate square bisectors\n * \n * @param {Array<[x,y]>} data \n */\nfunction cleanData(data){\n    data.forEach((e,i)=> {\n        data.forEach((d,j) => {\n            if(\n                i !== j &&\n                Math.abs(d[0] - e[0]) === Math.abs(d[1] - e[1])\n            ){\n                d[0] = d[0] + 1e-10*d[1];\n                d[1] = d[1] + 2e-10*d[0];\n            }\n        });\n    });\n    return data;\n}\n\n/**\n * Generate an L1 Voronoi diagram\n * \n * @param {array} sitePoints \n * @param {number} width \n * @param {number} height\n * @param {boolean} nudgeData\n * @returns {Array<Site>} \n */\n\nfunction generateL1Voronoi(sitePoints, width, height, nudgeData = true){\n\n    if(nudgeData){\n        console.log(\"nudging data\");\n        sitePoints = cleanData(sitePoints);\n    }\n\n    // sort points by x axis, breaking ties with y\n    let sites = sitePoints.sort((a,b)=>{\n        if(a[0] !== b[0]){\n            return a[0] - b[0];\n        }\n        else{\n            return a[1] - b[1];\n        }\n    }).map(e => {return {site:e, bisectors:[]}});\n\n    const findBisector = curryFindBisector(findL1Bisector, width, height);\n    const graph = recursiveSplit(sites, findBisector, width, height);\n\n    return graph.map(site => {\n        \n        site.polygonPoints = site.bisectors.reduce((total, bisector, index, bisectors)=>{\n\n            if(index === 0){\n\n                //find a bisector on an edge if you have one\n                let startBisector = bisectors.find(e => {\n                    return e.points.some(e => isPointonEdge(e));\n                }) || bisector;\n\n                let startingPoints = startBisector.points;\n                \n                if(isPointonEdge(startingPoints[startingPoints.length - 1])){\n                    startingPoints = startingPoints.reverse();\n                }\n\n                return {\n                    points:startingPoints,\n                    used:[startBisector]\n                }; \n            }\n            else{\n                let last = total.points[total.points.length -1];\n                \n                let nextBisector = bisectors.filter(e => total.used.every(d => e !== d)).reduce((c,e) => {\n                    \n                    let eDistance = distance(last, e.points[0]) < distance(last, e.points[e.points.length - 1]) ? distance(last, e.points[0]) : distance(last, e.points[e.points.length - 1]);   \n                    let cDistance = distance(last, c.points[0]) < distance(last, c.points[c.points.length - 1]) ? distance(last, c.points[0]) : distance(last, c.points[c.points.length - 1]);                       \n                    \n                    return eDistance < cDistance ? e : c;\n                },{points:[[Infinity,Infinity]]});\n\n                let nextPoints = nextBisector.points; \n\n                if(samePoint(nextPoints[nextPoints.length - 1], last)){\n                    nextPoints = nextPoints.reverse();\n                }\n\n                return {\n                    points:[...total.points, ...nextPoints],\n                    used: [...total.used, nextBisector]\n                };\n            }\n        },{}).points;\n        \n\n       const corners = [\n            [0,0],\n            [width, 0],\n            [width, height],\n            [0,height]\n        ];\n        \n        // finally we need to catch if it ends one an edge\n        if(\n            isPointonEdge(site.polygonPoints[0]) &&\n            isPointonEdge(site.polygonPoints[site.polygonPoints.length - 1]) &&\n            !arePointsOnSameEdge(site.polygonPoints[0], site.polygonPoints[site.polygonPoints.length - 1])\n        ){\n            \n            const filteredCorners = corners.filter(e => {\n                return site.bisectors.every(d => !bisectorIntersection({points:[e, site.site]}, d));     \n            });\n\n            site.polygonPoints = [...site.polygonPoints, ...filteredCorners];\n        }\n\n        site.polygonPoints = site.polygonPoints.sort((a,b)=> angle(site.site, a) - angle(site.site, b));\n\n        site.d = `M ${ site.polygonPoints.map(e => e.join(\" \")).join(\" L\")} Z`;\n\n        site.neighbors = site.bisectors.map(e => findHopTo(e, site.site).site);\n\n        return site;\n    });\n\n    function isPointonEdge(point) {\n        return point[0] === 0 ||\n               point[0] === width ||\n               point[1] === 0 ||\n               point[1] === height;\n    }\n\n    function arePointsOnSameEdge(P1, P2){\n        return (P1[0] === P2[0] && P1[0] === 0)     ||\n               (P1[0] === P2[0] && P1[0] === width) ||\n               (P1[1] === P2[1] && P1[1] === 0)     ||\n               (P1[1] === P2[1] && P1[1] === height)\n    }\n\n}\n\n/**\n * Recursivly split and merge sets of points\n * \n * @param {Array} splitArray \n * @param {function} findBisector \n * @param {Number} width \n * @param {Number} height\n * @returns {Array<Site>}\n */\nfunction recursiveSplit(splitArray, findBisector, width, height){\n    \n    // if its got more than two points in it, split it recursively\n    if(splitArray.length > 2){\n        let splitPoint = (splitArray.length - splitArray.length % 2) / 2\n\n        // merge the child diagrams\n        let L = recursiveSplit(splitArray.slice(0,splitPoint), findBisector, width, height);\n        let R = recursiveSplit(splitArray.slice(splitPoint), findBisector, width, height);\n\n        \n        // the current working sites\n        let neightborArray = R.sort((a,b) => distance(L[L.length - 1].site,a.site) - distance(L[L.length - 1].site,b.site));\n    \n        let startingInfo = determineStartingBisector(L[L.length - 1], neightborArray[0], width, null, findBisector);\n\n        let initialBisector = startingInfo.startingBisector;\n        let initialR = startingInfo.nearestNeighbor;\n        let initialL = startingInfo.w;\n\n        let upStrokeArray = walkMergeLine(initialR, initialL, initialBisector, [width,height], true, null, [], findBisector);\n        let downStrokeArray = walkMergeLine(initialR, initialL, initialBisector, [0,0], false, null, [], findBisector);\n\n        // combine all teh merge arrays\n        let mergeArray = [initialBisector, ...upStrokeArray, ...downStrokeArray];            \n\n        mergeArray.forEach(bisector => {\n            bisector.mergeLine = splitArray.length;\n            bisector.sites[0].bisectors = clearOutOrphans(bisector.sites[0], bisector.sites[1]);\n            bisector.sites[1].bisectors = clearOutOrphans(bisector.sites[1], bisector.sites[0]);                \n\n            bisector.sites.forEach(site => {\n                site.bisectors.push(bisector);\n            })\n        });\n\n        return [...L, ...R];    \n\n    }\n\n    // otherwise, determine te vertexes if its got two sites\n    else if(splitArray.length === 2){\n        let bisector = findBisector(...splitArray);\n        splitArray.forEach(e => { e.bisectors.push(bisector) });\n        return splitArray;\n    }\n\n    // if its got just one, just return it\n    else{\n        return splitArray;\n    }\n}\n\n/**\n * \n * @param {Site} currentR \n * @param {Site} currentL \n * @param {Bisector} currentBisector \n * @param {Array} currentCropPoint \n * @param {Boolean} goUp \n * @param {Bisector} crossedBorder \n * @param {Array} mergeArray - Array of Bisectors \n * @param {function} findBisector\n * @returns {Array<Bisector>} \n */\nfunction walkMergeLine(currentR, currentL, currentBisector, currentCropPoint, goUp, crossedBorder = null, mergeArray = [], findBisector){\n    \n    if(\n        !currentBisector.sites.every(e => e === currentR || e === currentL)\n    ){\n\n        currentBisector = findBisector(currentR,currentL);\n\n        trimBisector(currentBisector, crossedBorder, currentCropPoint);\n        \n        mergeArray.push(currentBisector);\n    }\n    \n    let cropLArray = currentL.bisectors\n                        .map(e => {return {bisector:e, point:bisectorIntersection(currentBisector, e)}})\n                        .filter(e => {\n                            let hopTo = e.bisector.sites.find(d => d !== currentL);\n                            return e.point && (goUp === isNewBisectorUpward(hopTo, currentL, currentR, goUp)) && (!samePoint(e.point, currentCropPoint) || e.bisector !== crossedBorder);\n                        })\n                        .sort((a, b) => {\n                            return angle(currentL.site, findHopTo(b.bisector, currentL).site) - angle(currentL.site, findHopTo(a.bisector, currentL).site)                            \n                        })\n                        .filter((e, i, candidates) => {\n                            let hopTo = findHopTo(e.bisector, currentL);\n                            let newMergeLine = findBisector(currentR, hopTo);\n                            trimBisector(newMergeLine, e.bisector, e.point);\n                            return candidates.every(d => !isBisectorTrapped(findHopTo(d.bisector, currentL), newMergeLine) || findHopTo(d.bisector, currentL) === hopTo);\n                        });\n    \n    let cropRArray = currentR.bisectors\n                        .map(e => {return {bisector:e, point:bisectorIntersection(currentBisector, e)}})\n                        .filter(e => {\n                            let hopTo = e.bisector.sites.find(d => d !== currentR);\n                            return e.point && (goUp === isNewBisectorUpward(hopTo, currentR, currentL, goUp)) && (!samePoint(e.point, currentCropPoint) || e.bisector !== crossedBorder);\n                        })\n                        .sort((a, b) => {\n                            return angle(currentR.site, findHopTo(a.bisector, currentR).site) - angle(currentR.site, findHopTo(b.bisector, currentR).site)                            \n                        })\n                        .filter((e, i, candidates) => {\n                            let hopTo = findHopTo(e.bisector, currentR);\n                            let newMergeLine = findBisector(currentL, hopTo);\n                            trimBisector(newMergeLine, e.bisector, e.point);\n                            return candidates.every(d => !isBisectorTrapped(findHopTo(d.bisector, currentR), newMergeLine) || findHopTo(d.bisector, currentR) === hopTo);\n                        });\n\n    let cropL = cropLArray.length > 0 && cropLArray[0] !== currentBisector ? cropLArray[0] : {bisector:null, point:goUp ? [Infinity, Infinity] : [-Infinity, -Infinity]};\n    let cropR = cropRArray.length > 0 && cropRArray[0] !== currentBisector ? cropRArray[0] : {bisector:null, point:goUp ? [Infinity, Infinity] : [-Infinity, -Infinity]};\n    \n    // If no intersection, we're done.\n    if(\n        (!cropL.bisector && !cropR.bisector)\n    ){\n        // If the final merge bisector is horizontal, check to see if there are orphans \n        let leftOrphan = checkForOphans(currentR, currentL, goUp, findBisector); \n        let rightOrphan = checkForOphans(currentL, currentR, goUp, findBisector);\n\n        if( \n            leftOrphan \n        ){\n            // Remove trapped bisector\n            leftOrphan.sites.forEach(site => {\n                site.bisectors = site.bisectors.filter(e => e !== leftOrphan);\n            });\n\n            let hopTo = findHopTo(leftOrphan, currentL);\n\n            currentR = findCorrectW(currentR, hopTo, findBisector);                        \n            let newMergeBisector = findBisector(hopTo, currentR);\n\n            mergeArray.push(newMergeBisector);\n\n            return walkMergeLine(currentR, hopTo, newMergeBisector, currentCropPoint, goUp, crossedBorder, mergeArray, findBisector);\n\n        }\n        else if(\n            rightOrphan\n        ){\n            // Remove trapped bisector\n            rightOrphan.sites.forEach(site => {\n                site.bisectors = site.bisectors.filter(e => e !== rightOrphan);\n            });\n\n            let hopTo = findHopTo(rightOrphan, currentR);\n\n            currentL = findCorrectW(currentL, hopTo, findBisector);                        \n            let newMergeBisector = findBisector(hopTo, currentL);\n            \n            mergeArray.push(newMergeBisector);                        \n\n            return walkMergeLine(hopTo, currentL, newMergeBisector, currentCropPoint, goUp, crossedBorder, mergeArray, findBisector);\n        }\n        \n        return mergeArray;\n    }\n\n    // determine which point  \n    if(determineFirstBorderCross(cropR, cropL, currentCropPoint) === \"right\"){\n        trimBisector(cropR.bisector, currentBisector, cropR.point);\n        trimBisector(currentBisector, cropR.bisector, cropR.point);\n        currentBisector.intersections.push(cropR.point);\n        crossedBorder = cropR.bisector;\n        currentR = cropR.bisector.sites.find(e => e !== currentR);\n        currentCropPoint = cropR.point;               \n    }\n    else if(determineFirstBorderCross(cropR,cropL,currentCropPoint) === \"left\"){\n        trimBisector(cropL.bisector, currentBisector, cropL.point);\n        trimBisector(currentBisector, cropL.bisector, cropL.point);\n        currentBisector.intersections.push(cropL.point);\n        crossedBorder = cropL.bisector;\n        currentL = cropL.bisector.sites.find(e => e !== currentL);\n        currentCropPoint = cropL.point;                                       \n    }\n    else{\n        trimBisector(cropR.bisector, currentBisector, cropR.point);\n        trimBisector(currentBisector, cropR.bisector, cropR.point);\n        currentBisector.intersections.push(cropR.point);\n        crossedBorder = cropR.bisector;\n        currentR = cropR.bisector.sites.find(e => e !== currentR);\n        currentCropPoint = cropR.point;\n\n        trimBisector(cropL.bisector, currentBisector, cropL.point);\n        trimBisector(currentBisector, cropL.bisector, cropL.point);\n        currentBisector.intersections.push(cropL.point);\n        crossedBorder = cropL.bisector;\n        currentL = cropL.bisector.sites.find(e => e !== currentL);\n        currentCropPoint = cropL.point;\n    }\n\n    return walkMergeLine(currentR, currentL, currentBisector, currentCropPoint, goUp, crossedBorder, mergeArray, findBisector);            \n    \n}\n\nfunction angle(P1, P2){\n    let angle = Math.atan2(P2[1] - P1[1], P2[0] - P1[0]);\n\n    if(angle < 0){\n        angle = Math.PI + Math.PI + angle; \n    }\n\n    return angle;\n}\n\nfunction determineFirstBorderCross(cropR,cropL,currentCropPoint){\n    if(Math.abs(cropR.point[1] - currentCropPoint[1]) === Math.abs(cropL.point[1] - currentCropPoint[1])){\n        return null\n    }\n    else{\n        return Math.abs(cropR.point[1] - currentCropPoint[1]) < Math.abs(cropL.point[1] - currentCropPoint[1]) ? \"right\" : \"left\";\n    }\n}\n\n/**\n * determine starting bisector for the merge process\n * \n * @param {Array} w - starting point in form [x, y] \n * @param {Array} nearestNeighbor point in form [x, y]\n * @param {number} width \n * @param {Array} lastIntersect point in form [x,y] \n * @param {function} findBisector  \n */\nfunction determineStartingBisector(w, nearestNeighbor, width, lastIntersect = null, findBisector){\n    \n    let z = [width, w.site[1]];\n    \n    if(!lastIntersect){\n        lastIntersect = w.site;\n    }\n\n    let zline = {points:[w.site,z]};\n\n    let intersection = nearestNeighbor.bisectors.map(bisector => {\n        return {point:bisectorIntersection(zline,bisector), bisector:bisector}\n    }).find(intersection => intersection.point);\n    \n    if(intersection && distance(w.site, intersection.point) > distance(nearestNeighbor.site, intersection.point)){\n        var startingBisector = findBisector(w, nearestNeighbor);\n        return {\n            startingBisector: startingBisector,\n            w:w,\n            nearestNeighbor: nearestNeighbor,\n            startingIntersection: intersection.point ? intersection.point : w.site\n        };\n    }\n    else if(intersection && distance(w.site, intersection.point) < distance(nearestNeighbor.site, intersection.point) && intersection.point[0] > lastIntersect[0] ){\n        let nextR = intersection.bisector.sites.find(e => e !== nearestNeighbor);\n        return determineStartingBisector(w, nextR, width, intersection.point, findBisector);\n    }\n    else{\n        w = findCorrectW(w,nearestNeighbor, findBisector);\n        \n        let startingBisector = findBisector(w, nearestNeighbor);\n\n        return {\n            startingBisector: startingBisector,\n            w:w,\n            nearestNeighbor: nearestNeighbor,\n            startingIntersection: intersection ? intersection.point : w.site\n        };\n\n    }\n\n};\n\n/**\n * Ensure that the starting point is correct and would not result in a trapped bisector\n * \n * @param {Array} w in form [x,y] \n * @param {Array} nearestNeighbor in form [x,y]\n * @param {function} findBisector\n * @returns {Array} in form [x,y] \n */\nfunction findCorrectW(w, nearestNeighbor, findBisector){\n    \n    var startingBisector = findBisector(w, nearestNeighbor);        \n\n    let wTrap = w.bisectors.map(e => {\n        let hopTo = findHopTo(e,w);\n        return {hopTo:hopTo, isTrapped:isBisectorTrapped(hopTo,startingBisector)}\n    })\n    .filter(e => e.isTrapped)\n    .sort((a,b) => distance(a.hopTo.site,nearestNeighbor.site) - distance(b.hopTo.site, nearestNeighbor.site))[0];\n\n    if(wTrap){\n        return findCorrectW(wTrap.hopTo, nearestNeighbor, findBisector);\n    }\n    else{\n        return w;\n    }\n}\n\n/**\n * Function that recursivly checks for orphaned besectors\n * \n * @param {Site} trapper \n * @param {Site} trapped \n * @param {boolean} goUp \n * @param {function} findBisector \n */\nfunction checkForOphans(trapper, trapped, goUp, findBisector){\n    \n    return trapped.bisectors.filter(bisector => {\n        let hopTo = findHopTo(bisector, trapped);\n        return goUp === hopTo.site[1] < trapped.site[1] && isBisectorTrapped(trapper,bisector); \n    }).sort((a,b) => {\n\n        let hopToA = findHopTo(a, trapped);\n        let hopToB = findHopTo(b, trapped);\n\n        let mergeLineA = findBisector(hopToA, trapper);\n        let mergeLineB = findBisector(hopToB, trapper);\n\n        let extremeA = getExtremePoint(mergeLineA, goUp);\n        let extremeB = getExtremePoint(mergeLineB, goUp);\n        \n        return goUp ? extremeB - extremeA : extremeA - extremeB;\n    })[0];\n    \n}\n\n/**\n * Currys find bisector function with the current width, height\n * \n * @param {function} callback \n * @param {number} width \n * @param {number} height\n * @return {function} \n */\nfunction curryFindBisector(callback, width, height){\n    return function(P1, P2){\n        return callback(P1, P2, width, height);\n    }\n}\n\n/**\n * Generate L1 bisector between two sites\n * \n * @param {Site} P1 \n * @param {Site} P2 \n * @param {number} width \n * @param {number} height\n * @returns {bisector} \n */\nfunction findL1Bisector(P1, P2, width, height){\n    \n    \n    let xDistance = P1.site[0] - P2.site[0];\n    let yDistance = P1.site[1] - P2.site[1];\n\n    let midpoint = [\n        (P1.site[0] + P2.site[0]) / 2,\n        (P1.site[1] + P2.site[1]) / 2\n    ];\n\n    let slope = yDistance/xDistance > 0 ? -1 : 1;\n\n    let intercetpt = midpoint[1] - midpoint[0] * slope;\n\n    let vertexes = [];\n    let up = null;\n    \n    if(Math.abs(xDistance) === Math.abs(yDistance)){\n        throw new Error(\n            `Square bisector: Points ${JSON.stringify(P1)} and ${JSON.stringify(P2)} are points on a square \n            (That is, their vertical distance is equal to their horizontal distance). Consider using the nudge points function or set the nudge data flag.`\n        );\n    }\n\n    if(samePoint(P1.site,P2.site)){\n        throw new Error(`Duplicate point: Points ${JSON.stringify(P1)} and ${JSON.stringify(P2)} are duplicates. please remove one`);\n    }\n    \n\n    \n    if(Math.abs(xDistance) === 0){\n        vertexes = [\n            [0, midpoint[1]],\n            [width, midpoint[1]]\n        ];\n\n        return {sites:[P1, P2], up:false, points:vertexes, intersections:[], compound:false};\n    }\n\n    if(Math.abs(yDistance) === 0){\n        vertexes = [\n            [midpoint[0], 0],\n            [midpoint[0], height]\n        ];\n\n        return {sites:[P1, P2], up:true, points:vertexes, intersections:[], compound:false};\n    }\n    if(Math.abs(xDistance) >= Math.abs(yDistance)){\n        vertexes = [\n            [(P1.site[1] - intercetpt) / slope, P1.site[1]],\n            [(P2.site[1] - intercetpt) / slope, P2.site[1]]\n        ];\n\n        up = true;\n    }\n    else{\n        vertexes = [\n            [P1.site[0] , (P1.site[0] * slope) + intercetpt ],\n            [P2.site[0] , (P2.site[0] * slope) + intercetpt ]\n        ];\n\n        up = false;\n    }\n\n    let bisector = {sites:[P1, P2], up:up, points:[], intersections:[], compound:false};    \n\n    if(up){\n        const sortedVerts = vertexes.sort((a,b) => a[1] - b[1]);\n\n        \n        bisector.points = [\n            [sortedVerts[0][0], 0],\n            ...sortedVerts,\n            [sortedVerts[1][0], height] \n        ].sort((a,b) => a[1] - b[1]);\n        \n    }\n    else{\n        const sortedVerts = vertexes.sort((a,b) => a[0] - b[0]);            \n        \n        bisector.points = [\n            [0,sortedVerts[0][1]],\n            ...sortedVerts,\n            [width,sortedVerts[1][1]]\n        ].sort((a,b) => a[0] - b[0]);\n    }\n\n    return bisector;\n}\n\n/**\n * Clear out orphans when a new merge line is created\n * \n * @param {Site} orphanage \n * @param {Site} trapPoint\n * @returns {Array<Bisector>} \n */\nfunction clearOutOrphans(orphanage, trapPoint){\n    return orphanage.bisectors.filter(bisector => !isBisectorTrapped(trapPoint, bisector));\n}\n\n/**\n * Finds other point across a bisector\n * \n * @param {Bisector} bisector \n * @param {Site} hopFrom\n * @returns {Site} \n */\nfunction findHopTo(bisector, hopFrom){\n    return bisector.sites.find(e => e !== hopFrom);\n}\n\n\n/**\n * Find L1 distance\n * \n * @param {Array} P1 in form [x,y] \n * @param {Array} P2 in form [x,y]\n * @returns {number}\n */\nfunction distance(P1, P2){\n    return Math.abs(P1[0] - P2[0]) + Math.abs(P1[1] - P2[1]);\n}\n\n/**\n * Determine if bisector is trapped in a site's polygon\n * Trapped is defined as all the points of a bisector being closer to the trap point than either if its own sites.\n * \n * @param {Site} trapPoint \n * @param {Bisector} bisector\n * @returns {boolean} \n */\nfunction isBisectorTrapped(trapPoint, bisector){\n    return bisector.points.every(point => distance(trapPoint.site, point) <= distance(bisector.sites[0].site, point) && distance(trapPoint.site, point) <= distance(bisector.sites[1].site, point));\n}\n\n/**\n * Find the highest or lowest point of a potential bisector.\n * \n * @param {Bisector} bisector \n * @param {boolean} goUp \n */\nfunction getExtremePoint(bisector, goUp){\n    return bisector.points.reduce((c,e)=>{\n        return goUp ? Math.max(e[1],c) : Math.min(e[1],c);\n    }, goUp ? -Infinity : Infinity);\n}\n\n/**\n * Trim a bisector at a particular point, discarding the points lying within the other polygon\n * \n * @param {Bisector} target \n * @param {Bisector} intersector \n * @param {Array} intersection in form [x,y] \n */\nfunction trimBisector(target, intersector, intersection){\n    \n    let polygonSite = intersector.sites.find(e => target.sites.find(d => d === e) === undefined);\n\n    let newPoints = target.points.filter(e => {\n        return distance(e, target.sites[0].site) < distance(e, polygonSite.site) && distance(e, target.sites[1].site) < distance(e, polygonSite.site);\n    });\n\n    newPoints.push(intersection);\n\n    target.points = newPoints.sort((a,b) => {\n        if(target.up){\n            return a[1] - b[1];\n        }\n        else{\n            return a[0] - b[0];\n        }\n    });\n\n};\n\n/**\n * Check to see if a bisector is traveling upward or downward with repect tot eh y axis\n * \n * @param {Site} hopTo \n * @param {Site} hopFrom \n * @param {Site} site\n * @returns {boolean} \n */\nfunction isNewBisectorUpward(hopTo, hopFrom, site, goUp){\n    \n    let slope = (hopTo.site[1] - site.site[1])/(hopTo.site[0] - site.site[0]);\n    let intercept = hopTo.site[1] - (slope * hopTo.site[0]);\n\n    // this needs to be here to account for bisectors \n    if(Math.abs(slope) === Infinity){\n        return site.site[1] > hopTo.site[1];\n    }\n\n    let isAboveLine = hopFrom.site[1] > (slope * hopFrom.site[0]) + intercept;\n    \n    return isAboveLine;\n}\n\n/**\n * Find intersection of two bisectors, if it exists\n * \n * @param {Bisector} B1 \n * @param {Bisector} B2\n * @returns {Array or boolean} \n */\nfunction bisectorIntersection(B1, B2){\n    if(B1 === B2){\n        return false;\n    }\n    for(let i = 0; i < B1.points.length - 1; i++){\n        for(let j = 0; j < B2.points.length - 1; j++){\n            let intersect = segementIntersection([B1.points[i], B1.points[i+1]], [B2.points[j], B2.points[j+1]], i, j);\n\n            if(intersect){\n                return intersect;\n            }\n        }\n    }\n\n    return false;\n}\n\n/**\n * find intersection of two line segements, if it exists\n * \n * @param {LineSegment} L1 - in form [[x,y],[x,y]] \n * @param {*} L2 - in form [[x,y],[x,y]]\n * @returns {Array or boolean}\n */\nfunction segementIntersection(L1, L2){\n    \n    var ua, ub, denom = (L2[1][1] - L2[0][1])*(L1[1][0] - L1[0][0]) - (L2[1][0] - L2[0][0])*(L1[1][1] - L1[0][1]);\n    \n    // If denom is zero, that mean that both segemnts are verticle or horizontal, and we need to account for that.\n    if (denom == 0) {\n        return null;\n    }\n    ua = ((L2[1][0] - L2[0][0])*(L1[0][1] - L2[0][1]) - (L2[1][1] - L2[0][1])*(L1[0][0] - L2[0][0]))/denom;\n    ub = ((L1[1][0] - L1[0][0])*(L1[0][1] - L2[0][1]) - (L1[1][1] - L1[0][1])*(L1[0][0] - L2[0][0]))/denom;\n\n    if(\n        !(ua >= 0 && ua <= 1 &&\n        ub >= 0 && ub <= 1)\n    ){\n        return false;\n    }\n\n    return [\n        L1[0][0] + ua*(L1[1][0] - L1[0][0]),\n        L1[0][1] + ua*(L1[1][1] - L1[0][1])\n    ];\n\n}\n\n/**\n * Determine if two points are the same point\n * \n * @param {Array} P1 - in form [x,y] \n * @param {Array} P2 - in form [x,y]\n */\nfunction samePoint(P1, P2){\n    return P1[0] === P2[0] && P1[1] === P2[1];\n}\n\n\nexport {generateVoronoiPoints, generateL1Voronoi, cleanData};\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1haW4uanMiXSwibmFtZXMiOlsibWFpbiIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJkaWFncmFtIiwibWVyZ2VQcm9jZXNzIiwid2lkdGgiLCJoZWlnaHQiLCJzZXRBdHRyaWJ1dGUiLCJyYW5kb21Ob3JtYWwiLCJzaGFycG5lc3MiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJNYXRoIiwicmFuZG9tIiwicmVkdWNlIiwiYyIsImUiLCJyYXciLCJmbG9vciIsInNpdGVzIiwic2xpY2UiLCJ0ZXh0Q29udGVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJzb3J0IiwiYSIsImIiLCJ2ZWN0b3JQb2ludHMiLCJjb25zb2xlIiwibG9nIiwiZm9yRWFjaCIsInNpdGUiLCJiaXNlY3RvcnMiLCJuZXdFbGVtZW50IiwiY3JlYXRlRWxlbWVudE5TIiwiYmlzZWN0b3IiLCJwb2ludHMiLCJqb2luIiwic3R5bGUiLCJzdHJva2UiLCJtZXJnZUxpbmUiLCJnZXRDb2xvciIsInN0cm9rZVdpZHRoIiwiYXBwZW5kQ2hpbGQiLCJkIiwic2l0ZUNpcmMiLCJjb2xvciJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7QUFFQSxJQUFJQSxPQUFPQyxTQUFTQyxjQUFULENBQXdCLE1BQXhCLENBQVg7QUFDQSxJQUFJQyxVQUFVRixTQUFTQyxjQUFULENBQXdCLFNBQXhCLENBQWQ7QUFDQSxJQUFJRSxlQUFlSCxTQUFTQyxjQUFULENBQXdCLGVBQXhCLENBQW5CO0FBQ0EsSUFBSUcsUUFBUSxHQUFaO0FBQ0EsSUFBSUMsU0FBUyxHQUFiO0FBQ0FILFFBQVFJLFlBQVIsQ0FBcUIsUUFBckIsRUFBK0JELE1BQS9CO0FBQ0FILFFBQVFJLFlBQVIsQ0FBcUIsT0FBckIsRUFBOEJGLEtBQTlCO0FBQ0FELGFBQWFHLFlBQWIsQ0FBMEIsUUFBMUIsRUFBb0NELE1BQXBDO0FBQ0FGLGFBQWFHLFlBQWIsQ0FBMEIsT0FBMUIsRUFBbUNGLEtBQW5DOztBQUVBLFNBQVNHLFlBQVQsQ0FBc0JDLFNBQXRC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QyxhQUFTUCxLQUFULENBQWU1QixJQUFmLEdBQXNCLE1BQXRCLENBL0J3QixDQStCTTtBQUM5QlIsWUFBUXlDLFdBQVIsQ0FBb0JFLFFBQXBCO0FBQ0gsQ0FqQ0Q7O0FBbUNBLFNBQVNKLFFBQVQsQ0FBa0JLLEtBQWxCLEVBQXdCO0FBQ3BCLFlBQU9BLEtBQVA7QUFDSSxhQUFLLENBQUw7QUFDSSxtQkFBTyxTQUFQO0FBQ0o7QUFDQSxhQUFLLENBQUw7QUFDSSxtQkFBTyxTQUFQO0FBQ0o7QUFDQSxhQUFLLEVBQUw7QUFDSSxtQkFBTyxTQUFQO0FBQ0o7QUFDQSxhQUFLLEVBQUw7QUFDSSxtQkFBTyxTQUFQO0FBQ0o7QUFDQSxhQUFLLEVBQUw7QUFDSSxtQkFBTyxTQUFQO0FBQ0o7QUFDQSxhQUFLLEdBQUw7QUFDSSxtQkFBTyxTQUFQO0FBQ0o7QUFDQSxhQUFLLEdBQUw7QUFDSSxtQkFBTyxTQUFQO0FBQ0o7QUFDQSxhQUFLLEdBQUw7QUFDSSxtQkFBTyxTQUFQO0FBQ0o7QUFDQSxhQUFLLElBQUw7QUFDSSxtQkFBTyxTQUFQO0FBQ0o7QUFDQSxhQUFLLElBQUw7QUFDSSxtQkFBTyxTQUFQO0FBQ0o7QUFDQTtBQUNJLG1CQUFPLFNBQVA7QUFoQ1I7QUFrQ0g7O0FBRUQiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Z2VuZXJhdGVWb3Jvbm9pUG9pbnRzLCBnZW5lcmF0ZUwxVm9yb25vaSwgY2xlYW5EYXRhfSBmcm9tIFwiLi9zcmMvdm9yb25vaS5qc1wiO1xuXG5sZXQgbWFpbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWFpblwiKTtcbmxldCBkaWFncmFtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkaWFncmFtXCIpO1xubGV0IG1lcmdlUHJvY2VzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWVyZ2UtcHJvY2Vzc1wiKTtcbmxldCB3aWR0aCA9IDQwMDtcbmxldCBoZWlnaHQgPSA0MDA7XG5kaWFncmFtLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQpO1xuZGlhZ3JhbS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aCk7XG5tZXJnZVByb2Nlc3Muc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG5tZXJnZVByb2Nlc3Muc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGgpO1xuXG5mdW5jdGlvbiByYW5kb21Ob3JtYWwoc2hhcnBuZXNzKXtcbiAgICByZXR1cm4gbmV3IEFycmF5KHNoYXJwbmVzcykuZmlsbCgwKS5tYXAoZSA9PiBNYXRoLnJhbmRvbSgpKS5yZWR1Y2UoKGMsZSkgPT4gYyArIGUsIDApIC8gc2hhcnBuZXNzO1xufVxuXG5sZXQgcmF3ID0gbmV3IEFycmF5KDEyOCkuZmlsbCgwKS5tYXAoZSA9PiBbTWF0aC5mbG9vcihyYW5kb21Ob3JtYWwoMikgKiB3aWR0aCksIE1hdGguZmxvb3IocmFuZG9tTm9ybWFsKDIpICogaGVpZ2h0KV0pO1xubGV0IHNpdGVzID0gcmF3LnNsaWNlKDApO1xuXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBvaW50c1wiKS50ZXh0Q29udGVudCA9IEpTT04uc3RyaW5naWZ5KHNpdGVzLnNvcnQoKGEsYikgPT4ge1xuICAgIGlmKGFbMF0gIT09IGJbMF0pe1xuICAgICAgICByZXR1cm4gYVswXSAtIGJbMF1cbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgcmV0dXJuIGFbMV0gLSBiWzFdXG4gICAgfVxufSksIG51bGwpO1xuXG5sZXQgdmVjdG9yUG9pbnRzID0gZ2VuZXJhdGVMMVZvcm9ub2koc2l0ZXMgLHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuY29uc29sZS5sb2codmVjdG9yUG9pbnRzKTtcbi8vIGRyYXcgc3ZnIHNoYXBlc1xudmVjdG9yUG9pbnRzLmZvckVhY2goc2l0ZSA9PntcbiAgICBcbiAgICBzaXRlLmJpc2VjdG9ycy5mb3JFYWNoKGJpc2VjdG9yID0+IHtcbiAgICAgICAgdmFyIG5ld0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCAncG9seWxpbmUnKTsgLy9DcmVhdGUgYSBwYXRoIGluIFNWRydzIG5hbWVzcGFjZVxuICAgICAgICBuZXdFbGVtZW50LnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBiaXNlY3Rvci5wb2ludHMubWFwKGUgPT4gZS5qb2luKFwiLFwiKSkuam9pbihcIiBcIikpOyAvL1NldCBwYXRoJ3MgZGF0YVxuICAgICAgICBuZXdFbGVtZW50LnNldEF0dHJpYnV0ZShcInBhcmVudHNcIiwgYmlzZWN0b3Iuc2l0ZXMubWFwKGUgPT4gZS5zaXRlLmpvaW4oXCIsXCIpKS5qb2luKFwiIHwgXCIpKTtcbiAgICAgICAgbmV3RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzaXRlXCIsIHNpdGUuc2l0ZS5qb2luKFwiLFwiKSk7XG4gICAgICAgIG5ld0VsZW1lbnQuc3R5bGUuc3Ryb2tlID0gYmlzZWN0b3IubWVyZ2VMaW5lID8gZ2V0Q29sb3IoYmlzZWN0b3IubWVyZ2VMaW5lKSA6IFwiIzAwMFwiOyAvL1NldCBzdHJva2UgY29sb3VyXG4gICAgICAgIG5ld0VsZW1lbnQuc3R5bGUuZmlsbCA9IFwibm9uZVwiO1xuICAgICAgICBuZXdFbGVtZW50LnN0eWxlLnN0cm9rZVdpZHRoID0gXCIxcHhcIjsgLy9TZXQgc3Ryb2tlIHdpZHRoXG4gICAgICAgIG1lcmdlUHJvY2Vzcy5hcHBlbmRDaGlsZChuZXdFbGVtZW50KTtcbiAgICB9KTtcbiAgICBcbiAgICB2YXIgbmV3RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsICdwYXRoJyk7IC8vQ3JlYXRlIGEgcGF0aCBpbiBTVkcncyBuYW1lc3BhY2VcbiAgICBuZXdFbGVtZW50LnNldEF0dHJpYnV0ZShcImRcIiwgc2l0ZS5kKTsgLy9TZXQgcGF0aCdzIGRhdGFcbiAgICBuZXdFbGVtZW50LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwicG9seWdvblwiKTsgLy9TZXQgcGF0aCdzIGRhdGEgICAgXG4gICAgbmV3RWxlbWVudC5zdHlsZS5zdHJva2UgPSBcIiMwMDBcIjsgLy9TZXQgc3Ryb2tlIGNvbG91clxuICAgIG5ld0VsZW1lbnQuc3R5bGUuc3Ryb2tlV2lkdGggPSBcIjFweFwiOyAvL1NldCBzdHJva2Ugd2lkdGhcbiAgICBkaWFncmFtLmFwcGVuZENoaWxkKG5ld0VsZW1lbnQpO1xuXG4gICAgdmFyIHNpdGVDaXJjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgJ2NpcmNsZScpOyAvL0NyZWF0ZSBhIHBhdGggaW4gU1ZHJ3MgbmFtZXNwYWNlXG4gICAgc2l0ZUNpcmMuc2V0QXR0cmlidXRlKFwiY3hcIiwgc2l0ZS5zaXRlWzBdKTsgLy9TZXQgcGF0aCdzIGRhdGFcbiAgICBzaXRlQ2lyYy5zZXRBdHRyaWJ1dGUoXCJjeVwiLCBzaXRlLnNpdGVbMV0pOyAvL1NldCBwYXRoJ3MgZGF0YVxuICAgIHNpdGVDaXJjLnNldEF0dHJpYnV0ZShcInJcIiwgMSk7IC8vU2V0IHBhdGgncyBkYXRhXG4gICAgc2l0ZUNpcmMuc3R5bGUuZmlsbCA9IFwiIzAwMFwiOyAvL1NldCBzdHJva2UgY29sb3VyXG4gICAgbWVyZ2VQcm9jZXNzLmFwcGVuZENoaWxkKHNpdGVDaXJjKTtcblxuICAgIHZhciBzaXRlQ2lyYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsICdjaXJjbGUnKTsgLy9DcmVhdGUgYSBwYXRoIGluIFNWRydzIG5hbWVzcGFjZVxuICAgIHNpdGVDaXJjLnNldEF0dHJpYnV0ZShcImN4XCIsIHNpdGUuc2l0ZVswXSk7IC8vU2V0IHBhdGgncyBkYXRhXG4gICAgc2l0ZUNpcmMuc2V0QXR0cmlidXRlKFwiY3lcIiwgc2l0ZS5zaXRlWzFdKTsgLy9TZXQgcGF0aCdzIGRhdGFcbiAgICBzaXRlQ2lyYy5zZXRBdHRyaWJ1dGUoXCJyXCIsIDEpOyAvL1NldCBwYXRoJ3MgZGF0YVxuICAgIHNpdGVDaXJjLnN0eWxlLmZpbGwgPSBcIiMwMDBcIjsgLy9TZXQgc3Ryb2tlIGNvbG91clxuICAgIGRpYWdyYW0uYXBwZW5kQ2hpbGQoc2l0ZUNpcmMpO1xufSk7XG5cbmZ1bmN0aW9uIGdldENvbG9yKGNvbG9yKXtcbiAgICBzd2l0Y2goY29sb3Ipe1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gXCIjNDI4NmY0XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gXCIjNDRmNDUzXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgcmV0dXJuIFwiIzkzMWQ3OFwiO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIHJldHVybiBcIiNmZjNjMzVcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICByZXR1cm4gXCIjZjRhZDQyXCI7XG4gICAgICAgIGJyZWFrOyAgIFxuICAgICAgICBjYXNlIDEyODpcbiAgICAgICAgICAgIHJldHVybiBcIiMwMDkxODJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjU2OlxuICAgICAgICAgICAgcmV0dXJuIFwiIzk5MzMwMFwiO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1MTI6XG4gICAgICAgICAgICByZXR1cm4gXCIjNjY5OTk5XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwMjQ6XG4gICAgICAgICAgICByZXR1cm4gXCIjODAwMDAwXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIwNDg6XG4gICAgICAgICAgICByZXR1cm4gXCIjMzMzMzAwXCI7XG4gICAgICAgIGJyZWFrOyAgIFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiIzAwMDAwMFwiO1xuICAgIH1cbn1cblxuLy9tYWluLnRleHRDb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodmVjdG9yUG9pbnRzLCBudWxsLCA0KTsiXX0="}